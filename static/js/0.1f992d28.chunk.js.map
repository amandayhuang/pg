{"version":3,"sources":["../../src/ui/Auth/components/Form.tsx","../../src/ui/Auth/components/internal/Label.tsx","../../src/ui/Auth/components/internal/Input.tsx","../../src/ui/Auth/components/EmailInput.tsx","../../src/ui/Auth/components/PasswordInput.tsx","../../src/ui/Auth/components/HeaderText.tsx","../../src/ui/Auth/components/internal/TextButton.tsx","../../src/ui/Auth/components/SecondaryButton.tsx","../../src/ui/Auth/components/SubmitButton.tsx","../../src/ui/Auth/components/Spacer.tsx","../../node_modules/react-hook-form/dist/index.esm.js"],"names":["Form","styled","props","display","justifyContent","minWidth","width","padding","boxShadow","borderRadius","flexDirection","fontFamily","margin","position","top","left","right","bottom","React","Label","TextFieldRoot","maxWidth","height","TextField","background","border","Bar","placeholder","id","htmlFor","label","autoComplete","type","required","HeaderText","fontSize","fontWeight","letterSpacing","marginBlockStart","marginBlockEnd","marginInlineStart","marginInlineEnd","marginTop","TextButton","cursor","color","whiteSpace","SecondaryButton","SubmitButtonRoot","SubmitButton","verticalAlign","textAlign","textOverflow","overflow","outline","boxSizing","style","isCheckBoxInput","element","isNullOrUndefined","value","isObjectType","isObject","Array","isArray","Date","getNodeParentName","name","substring","search","isNameInFieldArray","names","some","current","compact","filter","Boolean","isUndefined","val","undefined","get","obj","path","defaultValue","result","split","reduce","key","EVENTS","BLUR","CHANGE","VALIDATION_MODE","onBlur","onChange","onSubmit","onTouched","all","INPUT_VALIDATION_RULES","max","min","maxLength","minLength","pattern","validate","omit","source","copy","Object","assign","displayName","getProxyFormState","isProxyEnabled","formState","readFormStateRef","localReadFormStateRef","isRoot","Proxy","prop","isEmptyObject","keys","length","shouldRenderFormState","formStateData","find","convertToArrayPayload","isWeb","window","HTMLElement","document","appendErrors","validateAllFieldCriteria","errors","message","types","isKey","test","stringToPath","input","replace","set","object","index","tempPath","lastIndex","newValue","objValue","isNaN","focusFieldBy","fields","callback","fieldsNames","field","_f","ref","focus","refs","getFieldsValues","fieldsRef","output","disabled","every","isPrimitive","deepEqual","object1","object2","isErrorObject","keys1","keys2","val1","val2","deepMerge","target","targetValue","sourceValue","_a","setDirtyFields","values","defaultValues","dirtyFields","parentNode","parentName","setFieldArrayDirtyFields","slice","isString","isBoolean","unset","previousObjRef","updatePath","childObject","baseGet","k","objectRef","currentPaths","currentPathsLength","item","data","getFields","fieldsRefs","currentFields","isFileInput","isMultipleSelect","isRadioInput","defaultResult","isValid","validResult","getCheckboxValue","options","option","checked","map","attributes","getFieldValueAs","valueAsNumber","valueAsDate","setValueAs","NaN","getMultipleSelectValue","selected","defaultReturn","getRadioValue","previous","getFieldValue","files","hasValidation","mounted","skipValidation","isOnBlur","isOnChange","isOnTouch","isTouched","isReValidateOnBlur","isReValidateOnChange","isBlurEvent","isSubmitted","isOnAll","isFunction","isMessage","isRegex","RegExp","getValidateError","getValueAndMessage","validationData","validateField","a","inputValue","mount","error","isRadio","isCheckBox","isRadioOrCheckbox","isEmpty","appendErrorsCurry","bind","getMinMaxMessage","exceedMax","maxLengthMessage","minLengthMessage","maxType","minType","maxOutput","minOutput","valueDate","exceedMin","valueNumber","parseFloat","maxLengthOutput","minLengthOutput","patternValue","match","validateRef","validateError","validationResult","entries","validateFunction","validateResult","getValidationModes","mode","isOnSubmit","isHTMLElement","isRadioOrCheckboxFunction","Subscription","this","tearDowns","tearDown","push","teardown","Subscriber","observer","subscription","closed","add","next","Subject","observers","subscriber","isWindowUndefined","useForm","reValidateMode","resolver","context","shouldFocusError","shouldUnregister","criteriaMode","fieldsNamesRef","Set","formStateSubjectRef","unregisterFieldsNamesRef","watchSubjectRef","controllerSubjectRef","fieldArraySubjectRef","fieldArrayDefaultValuesRef","inFieldArrayActionRef","watchFieldsRef","isMountedRef","fieldsWithValidationRef","validFieldsRef","defaultValuesRef","isWatchAllRef","contextRef","resolverRef","fieldArrayNamesRef","validationMode","isValidateAllFieldCriteria","isDirty","isValidating","submitCount","touchedFields","isSubmitting","isSubmitSuccessful","updateFormState","formStateRef","getIsValid","shouldRenderBaseOnError","shouldRender","state","isWatched","previousError","updatedFormState","setFieldValue","rawValue","register","forEach","radioRef","selectRef","includes","checkboxRef","shouldDirty","updateAndGetDirtyState","shouldValidate","trigger","getIsDirty","formValues","isFieldDirty","isDirtyFieldExist","previousIsDirty","isChanged","executeValidation","skipReRender","executeSchemaOrResolverValidation","currentNames","validateForm","fieldError","fieldNames","schemaResult","Promise","fieldName","shouldFocus","setInternalValues","inputKey","has","isFieldWatched","updateValidAndValue","isWithinRefCallback","defaultChecked","then","handleChange","inputType","shouldSkipValidation","getValues","previousFormIsValid","parentNodeName","currentError","updateIsValid","previousIsValid","watchInternal","isGlobal","isArrayNames","fieldValues","unregister","inputName","delete","keepIsValid","keepError","keepValue","keepDirty","keepTouched","keepDefaultValue","registerFieldRef","contains","shouldUnmount","handleSubmit","onValid","onInvalid","e","preventDefault","persist","hasNoPromiseError","resetFromState","keepErrors","keepIsSubmitted","keepDefaultValues","keepSubmitCount","registerAbsentFields","FileList","formStateSubscription","subscribe","useFieldArraySubscription","unsubscribe","isLiveInDom","control","watch","info","setValue","isFieldArray","isReset","reset","keepStateOptions","updatedValues","keepValues","inputRef","closest","clearErrors","setError","setFocus"],"mappings":"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","file":"static/js/0.1f992d28.chunk.js","sourcesContent":["import React from 'react';\nimport styled from 'styled-components';\n\nconst Form = styled.form(props => ({\n    display: \"flex\",\n    justifyContent: \"center\",\n    minWidth: 300,\n    width: 380,\n    padding: '33px 55px',\n    boxShadow: '0 5px 10px 0 rgb(0 0 0 / 10%)',\n    borderRadius: 10,\n    flexDirection: 'column',\n    fontFamily: \"inherit\",\n    margin: '6% auto 50px',\n    '@media (max-width: 520px)': {\n        margin: '0px !important',\n        position: 'fixed !important',\n        top: 0,\n        left: 0,\n        right: 0,\n        bottom: 0,\n        width: 'initial !important'\n    },\n    ...(props.theme.form ? { ...props.theme.form } : {})\n}))\n\nexport default function (props: React.FormHTMLAttributes<HTMLFormElement>) {\n    return (\n        <Form {...props}>{props.children}</Form>\n    )\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst Label = styled.label(props => ({\n    display: \"none\",\n    fontFamily: \"inherit\",\n    ...(props.theme.textFieldLabel ? { ...props.theme.textFieldLabel } : {})\n}))\n\nexport default function (props: React.LabelHTMLAttributes<HTMLLabelElement>) {\n    return (<Label {...props} />)\n}\n","import React from 'react';\nimport { UseFormRegisterReturn } from 'react-hook-form';\nimport styled from 'styled-components';\nimport Label from './Label';\n\nconst TextFieldRoot = styled.div(props => ({\n    position: 'relative',\n    width: '100%',\n    maxWidth: '100%',\n    padding: 0,\n    height: 46,\n    fontFamily: \"inherit\",\n    ...(props.theme.textFieldRoot ? { ...props.theme.textFieldRoot } : {})\n}))\n\nconst TextField = styled.input(props => ({\n    display: \"block\",\n    width: '100%',\n    background: '0 0',\n    border: 'none',\n    fontFamily: \"inherit\",\n    ...(props.theme.textField ? { ...props.theme.textField } : {})\n}))\n\nconst Bar = styled.div(props => props.theme.textFieldBar ? { ...props.theme.textFieldBar } : {})\n\ninterface ITextField extends React.InputHTMLAttributes<HTMLInputElement> {\n    label: string\n    register(): UseFormRegisterReturn\n}\n\nexport default function (props: ITextField) {\n    return (\n        <TextFieldRoot>\n            <TextField placeholder=\"&nbsp;\" {...props} {...props.register()} id={\"textField-\" + props.label.replace(/[^a-zA-Z]+/g, '')} />\n            <Bar />\n            <Label htmlFor={\"textField-\" + props.label.replace(/[^a-zA-Z]+/g, '')}>{props.label}</Label>\n        </TextFieldRoot>\n    )\n}\n","import React, { forwardRef } from 'react';\nimport { UseFormRegisterReturn } from 'react-hook-form';\nimport Input from './internal/Input';\n\ninterface ITextField extends React.InputHTMLAttributes<HTMLInputElement> {\n    label?: string\n    register(): UseFormRegisterReturn\n}\n\nexport default function(props: ITextField) {\n    return (\n        <Input label=\"Email\" autoComplete=\"email\" {...props} type=\"email\" required />\n    )\n}\n","import React from 'react';\nimport { UseFormRegisterReturn } from 'react-hook-form';\nimport Input from './internal/Input';\n\ninterface ITextField extends React.InputHTMLAttributes<HTMLInputElement> {\n    label?: string;\n    register(): UseFormRegisterReturn;\n}\n\nexport default function(props: ITextField) {\n    return (\n        <Input label=\"Password\" {...props} type=\"password\" required />\n    )\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst HeaderText = styled.h1(props => ({\n    fontFamily: \"inherit\",\n    fontSize: 24,\n    fontWeight: 500,\n    letterSpacing: -.2,\n    marginBlockStart: '0.67em',\n    marginBlockEnd: '0.67em',\n    marginInlineStart: 0,\n    marginInlineEnd: 0,\n    marginTop: '16px !important',\n    ...(props.theme.headerText ? { ...props.theme.headerText } : {})\n}))\n\nexport default function (props: React.HTMLAttributes<HTMLHeadingElement>) {\n    return (\n        <HeaderText {...props} />\n    )\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst TextButton = styled.button(props => ({\n    cursor: \"pointer\",\n    color: '#635bff',\n    whiteSpace: 'nowrap',\n    fontWeight: 500,\n    fontSize: 14,\n    margin: 0,\n    background: 'none',\n    border: 'none',\n    ...(props.theme.textButton ? { ...props.theme.textButton } : {})\n}))\n\nexport default function (props: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n    return (\n        <TextButton {...props} type=\"button\" />\n    )\n}\n","import React from 'react';\nimport TextButton from './internal/TextButton';\nimport styled from 'styled-components';\n\nconst SecondaryButton = styled(TextButton)(props => ({\n    margin: '15px',\n    ...(props.theme.secondaryButton ? { ...props.theme.secondaryButton } : {})\n}))\n\nexport default function (props: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n    return (\n        <SecondaryButton {...props} />\n    )\n}\n","import React from 'react';\nimport styled from 'styled-components';\n\nconst SubmitButtonRoot = styled.div(props => props.theme.submitButtonRoot ? props.theme.submitButtonRoot : {});\n\nconst SubmitButton = styled.button(props => ({\n    position: 'relative',\n    border: \"none\",\n    verticalAlign: \"middle\",\n    textAlign: \"center\",\n    textOverflow: \"ellipsis\",\n    overflow: \"hidden\",\n    outline: \"none\",\n    cursor: \"pointer\",\n    boxSizing: 'border-box',\n    ...(props.theme.submitButton ? { ...props.theme.submitButton } : {})\n}))\n\nexport default function (props: React.ButtonHTMLAttributes<HTMLButtonElement>) {\n    return (\n        <SubmitButtonRoot>\n            <SubmitButton type=\"submit\" {...props} />\n        </SubmitButtonRoot>\n    )\n}\n","import React from 'react';\n\ninterface ISpacer {\n    size?: \"xlarge\" | \"large\" | \"medium\" | \"small\"\n}\n\nexport default function (props: ISpacer) {\n    switch (props.size) {\n        case \"xlarge\":\n            return <div style={{ height: 64 }} />   \n        case \"large\":\n            return <div style={{ height: 58 }} />            \n        case \"small\":\n            return <div style={{ height: 16 }} />\n        default:\n            return <div style={{ height: 37 }} />\n    }\n}\n","import * as React from 'react';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) &&\r\n    !Array.isArray(value) &&\r\n    isObjectType(value) &&\r\n    !(value instanceof Date);\n\nvar getControllerValue = (event) => isObject(event) && event.target\r\n    ? isCheckBoxInput(event.target)\r\n        ? event.target.checked\r\n        : event.target.value\r\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/.\\d/)) || name;\n\nvar isNameInFieldArray = (names, name) => [...names].some((current) => getNodeParentName(name) === current);\n\nvar compact = (value) => value.filter(Boolean);\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (obj, path, defaultValue) => {\r\n    if (isObject(obj) && path) {\r\n        const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n        return isUndefined(result) || result === obj\r\n            ? isUndefined(obj[path])\r\n                ? defaultValue\r\n                : obj[path]\r\n            : result;\r\n    }\r\n    return undefined;\r\n};\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    onTouched: 'onTouched',\r\n    all: 'all',\r\n};\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nvar omit = (source, key) => {\r\n    const copy = Object.assign({}, source);\r\n    delete copy[key];\r\n    return copy;\r\n};\n\nconst FormContext = React.createContext(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => React.useContext(FormContext);\r\nconst FormProvider = (props) => (React.createElement(FormContext.Provider, { value: omit(props, 'children') }, props.children));\n\nvar getProxyFormState = (isProxyEnabled, formState, readFormStateRef, localReadFormStateRef, isRoot = true) => isProxyEnabled\r\n    ? new Proxy(formState, {\r\n        get: (obj, prop) => {\r\n            if (prop in obj) {\r\n                if (readFormStateRef.current[prop] !== VALIDATION_MODE.all) {\r\n                    readFormStateRef.current[prop] = isRoot\r\n                        ? VALIDATION_MODE.all\r\n                        : true;\r\n                }\r\n                localReadFormStateRef &&\r\n                    (localReadFormStateRef.current[prop] = true);\r\n                return obj[prop];\r\n            }\r\n            return undefined;\r\n        },\r\n    })\r\n    : formState;\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formStateData, readFormStateRef, isRoot) => {\r\n    const formState = omit(formStateData, 'name');\r\n    return (isEmptyObject(formState) ||\r\n        Object.keys(formState).length >= Object.keys(readFormStateRef).length ||\r\n        Object.keys(formState).find((key) => readFormStateRef[key] ===\r\n            (isRoot ? VALIDATION_MODE.all : true)));\r\n};\n\nvar convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];\n\nvar isWeb = typeof window !== 'undefined' &&\r\n    typeof window.HTMLElement !== 'undefined' &&\r\n    typeof document !== 'undefined';\n\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== 'undefined';\n\nfunction useFormState(props) {\r\n    const { control, name } = props || {};\r\n    const methods = useFormContext();\r\n    const { formStateRef, formStateSubjectRef, readFormStateRef } = control || methods.control;\r\n    const nameRef = React.useRef(name);\r\n    nameRef.current = name;\r\n    const [formState, updateFormState] = React.useState(formStateRef.current);\r\n    const readFormState = React.useRef({\r\n        isDirty: false,\r\n        dirtyFields: false,\r\n        touchedFields: false,\r\n        isValidating: false,\r\n        isValid: false,\r\n        errors: false,\r\n    });\r\n    React.useEffect(() => {\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next: (formState) => (!nameRef.current ||\r\n                !formState.name ||\r\n                convertToArrayPayload(nameRef.current).includes(formState.name)) &&\r\n                shouldRenderFormState(formState, readFormState.current) &&\r\n                updateFormState(Object.assign(Object.assign({}, formStateRef.current), formState)),\r\n        });\r\n        return () => formStateSubscription.unsubscribe();\r\n    }, []);\r\n    return getProxyFormState(isProxyEnabled, formState, readFormStateRef, readFormState, false);\r\n}\n\nfunction useController({ name, rules, defaultValue, control, shouldUnregister, }) {\r\n    const methods = useFormContext();\r\n    const { defaultValuesRef, register, fieldsRef, unregister, fieldArrayNamesRef, controllerSubjectRef, shouldUnmount, inFieldArrayActionRef, } = control || methods.control;\r\n    const { onChange, onBlur, ref } = register(name, rules);\r\n    const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    const [value, setInputStateValue] = React.useState(isUndefined(get(fieldsRef.current, name)._f.value) || isFieldArray\r\n        ? isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue\r\n        : get(fieldsRef.current, name)._f.value);\r\n    const formState = useFormState({\r\n        control: control || methods.control,\r\n        name,\r\n    });\r\n    const field = get(fieldsRef.current, name);\r\n    field._f.value = value;\r\n    React.useEffect(() => {\r\n        const controllerSubscription = controllerSubjectRef.current.subscribe({\r\n            next: (data) => (!data.name || name === data.name) &&\r\n                setInputStateValue(get(data.values, name)),\r\n        });\r\n        return () => {\r\n            controllerSubscription.unsubscribe();\r\n            const shouldUnmountField = shouldUnmount || shouldUnregister;\r\n            if (isFieldArray\r\n                ? shouldUnmountField && !inFieldArrayActionRef.current\r\n                : shouldUnmountField) {\r\n                unregister(name);\r\n            }\r\n            else if (get(fieldsRef.current, name)) {\r\n                get(fieldsRef.current, name)._f.mount = false;\r\n            }\r\n        };\r\n    }, [name]);\r\n    return {\r\n        field: {\r\n            onChange: (event) => {\r\n                const value = getControllerValue(event);\r\n                setInputStateValue(value);\r\n                onChange({\r\n                    target: {\r\n                        value,\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.CHANGE,\r\n                });\r\n            },\r\n            onBlur: () => {\r\n                onBlur({\r\n                    target: {\r\n                        name: name,\r\n                    },\r\n                    type: EVENTS.BLUR,\r\n                });\r\n            },\r\n            name,\r\n            value,\r\n            ref: (elm) => elm && ref(elm),\r\n        },\r\n        formState,\r\n        fieldState: {\r\n            invalid: !!get(formState.errors, name),\r\n            isDirty: !!get(formState.dirtyFields, name),\r\n            isTouched: !!get(formState.touchedFields, name),\r\n            error: get(formState.errors, name),\r\n        },\r\n    };\r\n}\n\nconst Controller = (props) => props.render(useController(props));\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\r\n    ? Object.assign(Object.assign({}, errors[name]), { types: Object.assign(Object.assign({}, (errors[name] && errors[name].types ? errors[name].types : {})), { [type]: message || true }) }) : {};\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || Array.isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nconst focusFieldBy = (fields, callback, fieldsNames) => {\r\n    for (const key of fieldsNames || Object.keys(fields)) {\r\n        const field = get(fields, key);\r\n        if (field) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            if (_f && callback(_f.name)) {\r\n                if (_f.ref.focus && isUndefined(_f.ref.focus())) {\r\n                    break;\r\n                }\r\n                else if (_f.refs) {\r\n                    _f.refs[0].focus();\r\n                    break;\r\n                }\r\n            }\r\n            else if (isObject(current)) {\r\n                focusFieldBy(current, callback);\r\n            }\r\n        }\r\n    }\r\n};\n\nconst getFieldsValues = (fieldsRef, output = {}) => {\r\n    for (const name in fieldsRef.current) {\r\n        const field = fieldsRef.current[name];\r\n        if (field && !isNullOrUndefined(output)) {\r\n            const _f = field._f;\r\n            const current = omit(field, '_f');\r\n            set(output, name, _f && _f.ref\r\n                ? _f.ref.disabled || (_f.refs && _f.refs.every((ref) => ref.disabled))\r\n                    ? undefined\r\n                    : _f.value\r\n                : Array.isArray(field)\r\n                    ? []\r\n                    : {});\r\n            current &&\r\n                getFieldsValues({\r\n                    current,\r\n                }, output[name]);\r\n        }\r\n    }\r\n    return output;\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nvar mapIds = (values = [], keyName) => values.map((value) => (Object.assign({ [keyName]: (value && value[keyName]) || generateId() }, value)));\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2, isErrorObject) {\r\n    if (isPrimitive(object1) ||\r\n        isPrimitive(object2) ||\r\n        object1 instanceof Date ||\r\n        object2 instanceof Date) {\r\n        return object1 === object2;\r\n    }\r\n    if (!React.isValidElement(object1)) {\r\n        const keys1 = Object.keys(object1);\r\n        const keys2 = Object.keys(object2);\r\n        if (keys1.length !== keys2.length) {\r\n            return false;\r\n        }\r\n        for (const key of keys1) {\r\n            const val1 = object1[key];\r\n            if (!(isErrorObject && key === 'ref')) {\r\n                const val2 = object2[key];\r\n                if ((isObject(val1) || Array.isArray(val1)) &&\r\n                    (isObject(val2) || Array.isArray(val2))\r\n                    ? !deepEqual(val1, val2, isErrorObject)\r\n                    : val1 !== val2) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}\n\nfunction deepMerge(target, source) {\r\n    if (isPrimitive(target) || isPrimitive(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        try {\r\n            target[key] =\r\n                (isObject(targetValue) && isObject(sourceValue)) ||\r\n                    (Array.isArray(targetValue) && Array.isArray(sourceValue))\r\n                    ? deepMerge(targetValue, sourceValue)\r\n                    : sourceValue;\r\n        }\r\n        catch (_a) { }\r\n    }\r\n    return target;\r\n}\n\nfunction setDirtyFields(values, defaultValues, dirtyFields, parentNode, parentName) {\r\n    let index = -1;\r\n    while (++index < values.length) {\r\n        for (const key in values[index]) {\r\n            if (Array.isArray(values[index][key])) {\r\n                !dirtyFields[index] && (dirtyFields[index] = {});\r\n                dirtyFields[index][key] = [];\r\n                setDirtyFields(values[index][key], get(defaultValues[index] || {}, key, []), dirtyFields[index][key], dirtyFields[index], key);\r\n            }\r\n            else {\r\n                deepEqual(get(defaultValues[index] || {}, key), values[index][key])\r\n                    ? set(dirtyFields[index] || {}, key)\r\n                    : (dirtyFields[index] = Object.assign(Object.assign({}, dirtyFields[index]), { [key]: true }));\r\n            }\r\n        }\r\n        parentNode &&\r\n            !dirtyFields.length &&\r\n            delete parentNode[parentName];\r\n    }\r\n    return dirtyFields;\r\n}\r\nvar setFieldArrayDirtyFields = (values, defaultValues, dirtyFields) => deepMerge(setDirtyFields(values, defaultValues, dirtyFields.slice(0, values.length)), setDirtyFields(defaultValues, values, dirtyFields.slice(0, values.length)));\n\nfunction append(data, value) {\r\n    return [...data, ...convertToArrayPayload(value)];\r\n}\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...convertToArrayPayload(value),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (Array.isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...convertToArrayPayload(value), ...data];\r\n}\n\nfunction removeAtIndexes(data, indexes) {\r\n    let i = 0;\r\n    const temp = [...data];\r\n    for (const index of indexes) {\r\n        temp.splice(index - i, 1);\r\n        i++;\r\n    }\r\n    return compact(temp).length ? temp : [];\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    data[indexA] = [data[indexB], (data[indexB] = data[indexA])][0];\r\n};\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nfunction baseGet(object, updatePath) {\r\n    const length = updatePath.slice(0, -1).length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (Array.isArray(objectRef) &&\r\n                        !objectRef.filter((data) => (isObject(data) && !isEmptyObject(data)) || isBoolean(data)).length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst useFieldArray = ({ control, name, keyName = 'id', shouldUnregister, }) => {\r\n    const methods = useFormContext();\r\n    const focusNameRef = React.useRef('');\r\n    const isMountedRef = React.useRef(false);\r\n    const { isWatchAllRef, watchFieldsRef, getIsDirty, watchSubjectRef, fieldArraySubjectRef, fieldArrayNamesRef, fieldsRef, defaultValuesRef, formStateRef, formStateSubjectRef, readFormStateRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValuesRef, unregister, shouldUnmount, inFieldArrayActionRef, } = control || methods.control;\r\n    const [fields, setFields] = React.useState(mapIds(get(fieldsRef.current, name) && isMountedRef.current\r\n        ? get(getFieldsValues(fieldsRef), name)\r\n        : get(fieldArrayDefaultValuesRef.current, getNodeParentName(name))\r\n            ? get(fieldArrayDefaultValuesRef.current, name, [])\r\n            : get(defaultValuesRef.current, name, []), keyName));\r\n    set(fieldArrayDefaultValuesRef.current, name, [...fields]);\r\n    fieldArrayNamesRef.current.add(name);\r\n    const omitKey = (fields) => fields.map((field) => omit((field || {}), keyName));\r\n    const getCurrentFieldsValues = () => {\r\n        const values = get(getFieldsValues(fieldsRef), name, []);\r\n        return mapIds(get(fieldArrayDefaultValuesRef.current, name, []).map((item, index) => (Object.assign(Object.assign({}, item), values[index]))), keyName);\r\n    };\r\n    const getFocusDetail = (index, options) => options\r\n        ? !isUndefined(options.focusIndex)\r\n            ? `${name}.${options.focusIndex}`\r\n            : options.focusName\r\n                ? options.focusName\r\n                : !options.shouldFocus\r\n                    ? ''\r\n                    : `${name}.${index}`\r\n        : `${name}.${index}`;\r\n    const resetFields = (index) => convertToArrayPayload(index).forEach((currentIndex) => set(fieldsRef.current, `${name}${isUndefined(currentIndex) ? '' : `.${currentIndex}`}`, isUndefined(currentIndex) ? [] : undefined));\r\n    const setFieldsAndNotify = (fieldsValues = []) => setFields(mapIds(fieldsValues, keyName));\r\n    const cleanup = (ref) => !compact(get(ref, name, [])).length && unset(ref, name);\r\n    const updateDirtyFieldsWithDefaultValues = (updatedFieldArrayValues) => updatedFieldArrayValues &&\r\n        set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n    const batchStateUpdate = (method, args, updatedFieldArrayValues = [], shouldSet = true) => {\r\n        inFieldArrayActionRef.current = true;\r\n        if (get(fieldsRef.current, name)) {\r\n            const output = method(get(fieldsRef.current, name), args.argA, args.argB);\r\n            shouldSet && set(fieldsRef.current, name, output);\r\n        }\r\n        if (Array.isArray(get(formStateRef.current.errors, name))) {\r\n            const output = method(get(formStateRef.current.errors, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.errors, name, output);\r\n            cleanup(formStateRef.current.errors);\r\n        }\r\n        if (readFormStateRef.current.touchedFields &&\r\n            get(formStateRef.current.touchedFields, name)) {\r\n            const output = method(get(formStateRef.current.touchedFields, name), args.argA, args.argB);\r\n            shouldSet && set(formStateRef.current.touchedFields, name, output);\r\n            cleanup(formStateRef.current.touchedFields);\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(omitKey(updatedFieldArrayValues), get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n            updateDirtyFieldsWithDefaultValues(updatedFieldArrayValues);\r\n            cleanup(formStateRef.current.dirtyFields);\r\n        }\r\n        if (readFormStateRef.current.isValid) {\r\n            set(validFieldsRef.current, name, method(get(validFieldsRef.current, name, []), args.argA));\r\n            cleanup(validFieldsRef.current);\r\n            set(fieldsWithValidationRef.current, name, method(get(fieldsWithValidationRef.current, name, []), args.argA));\r\n            cleanup(fieldsWithValidationRef.current);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isDirty: getIsDirty(name, omitKey(updatedFieldArrayValues)),\r\n            errors: formStateRef.current.errors,\r\n            isValid: formStateRef.current.isValid,\r\n        });\r\n    };\r\n    const registerFieldArray = (values, index = 0, parentName = '') => values.forEach((appendValueItem, valueIndex) => !isPrimitive(appendValueItem) &&\r\n        Object.entries(appendValueItem).forEach(([key, value]) => {\r\n            const inputName = `${parentName || name}.${parentName ? valueIndex : index + valueIndex}.${key}`;\r\n            Array.isArray(value)\r\n                ? registerFieldArray(value, valueIndex, inputName)\r\n                : set(fieldsRef.current, inputName, {\r\n                    _f: {\r\n                        ref: {\r\n                            name: inputName,\r\n                        },\r\n                        name: inputName,\r\n                        value: isPrimitive(value) ? value : Object.assign({}, value),\r\n                    },\r\n                });\r\n        }));\r\n    const append$1 = (value, options) => {\r\n        const appendValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValues = append(getCurrentFieldsValues(), appendValue);\r\n        const currentIndex = updatedFieldArrayValues.length - appendValue.length;\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(append, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues, false);\r\n        registerFieldArray(appendValue, currentIndex);\r\n        focusNameRef.current = getFocusDetail(currentIndex, options);\r\n    };\r\n    const prepend$1 = (value, options) => {\r\n        const prependValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValues = prepend(getCurrentFieldsValues(), prependValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(prepend, {\r\n            argA: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(prependValue);\r\n        focusNameRef.current = getFocusDetail(0, options);\r\n    };\r\n    const remove = (index) => {\r\n        const updatedFieldArrayValues = removeArrayAt(getCurrentFieldsValues(), index);\r\n        resetFields(index);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(removeArrayAt, {\r\n            argA: index,\r\n        }, updatedFieldArrayValues);\r\n    };\r\n    const insert$1 = (index, value, options) => {\r\n        const insertValue = convertToArrayPayload(value);\r\n        const updatedFieldArrayValues = insert(getCurrentFieldsValues(), index, insertValue);\r\n        setFieldsAndNotify(updatedFieldArrayValues);\r\n        batchStateUpdate(insert, {\r\n            argA: index,\r\n            argB: fillEmptyArray(value),\r\n        }, updatedFieldArrayValues);\r\n        registerFieldArray(insertValue, index);\r\n        focusNameRef.current = getFocusDetail(index, options);\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        batchStateUpdate(swapArrayAt, {\r\n            argA: indexA,\r\n            argB: indexB,\r\n        }, fieldValues, false);\r\n        setFieldsAndNotify(fieldValues);\r\n    };\r\n    const move = (from, to) => {\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        setFieldsAndNotify(fieldValues);\r\n        batchStateUpdate(moveArrayAt, {\r\n            argA: from,\r\n            argB: to,\r\n        }, fieldValues, false);\r\n    };\r\n    React.useEffect(() => {\r\n        inFieldArrayActionRef.current = false;\r\n        if (isWatchAllRef.current) {\r\n            formStateSubjectRef.current.next({});\r\n        }\r\n        else {\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (name.startsWith(watchField)) {\r\n                    formStateSubjectRef.current.next({});\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        watchSubjectRef.current.next({\r\n            name,\r\n            formValues: getFieldsValues(fieldsRef),\r\n        });\r\n        focusNameRef.current &&\r\n            focusFieldBy(fieldsRef.current, (key) => isString(key) && key.startsWith(focusNameRef.current));\r\n        focusNameRef.current = '';\r\n        fieldArraySubjectRef.current.next({\r\n            name,\r\n            fields: omitKey([...fields]),\r\n        });\r\n    }, [fields, name]);\r\n    React.useEffect(() => {\r\n        const fieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next({ name: inputFieldArrayName, fields, isReset }) {\r\n                if (isReset) {\r\n                    unset(fieldsRef.current, inputFieldArrayName || name);\r\n                    inputFieldArrayName\r\n                        ? set(fieldArrayDefaultValuesRef.current, inputFieldArrayName, fields)\r\n                        : (fieldArrayDefaultValuesRef.current = fields);\r\n                    setFieldsAndNotify(get(fieldArrayDefaultValuesRef.current, name));\r\n                }\r\n            },\r\n        });\r\n        !get(fieldsRef.current, name) && set(fieldsRef.current, name, []);\r\n        isMountedRef.current = true;\r\n        return () => {\r\n            fieldArraySubscription.unsubscribe();\r\n            (shouldUnmount || shouldUnregister) &&\r\n                unregister(name);\r\n        };\r\n    }, []);\r\n    return {\r\n        swap: React.useCallback(swap, [name]),\r\n        move: React.useCallback(move, [name]),\r\n        prepend: React.useCallback(prepend$1, [name]),\r\n        append: React.useCallback(append$1, [name]),\r\n        remove: React.useCallback(remove, [name]),\r\n        insert: React.useCallback(insert$1, [name]),\r\n        fields: fields,\r\n    };\r\n};\n\nfunction getFields(fieldsNames, fieldsRefs) {\r\n    const currentFields = {};\r\n    for (const name of fieldsNames) {\r\n        const field = get(fieldsRefs, name);\r\n        if (field) {\r\n            !isKey(name)\r\n                ? set(currentFields, name, field._f)\r\n                : (currentFields[name] = field._f);\r\n        }\r\n    }\r\n    return currentFields;\r\n}\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isMultipleSelect = (element) => element.type === `select-multiple`;\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (Array.isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.checked && !option.disabled)\r\n                .map((option) => option.value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        return options[0].checked && !options[0].disabled\r\n            ? // @ts-expect-error expected to work in the browser\r\n                options[0].attributes && !isUndefined(options[0].attributes.value)\r\n                    ? isUndefined(options[0].value) || options[0].value === ''\r\n                        ? validResult\r\n                        : { value: options[0].value, isValid: true }\r\n                    : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)\r\n    ? value\r\n    : valueAsNumber\r\n        ? value === ''\r\n            ? NaN\r\n            : +value\r\n        : valueAsDate\r\n            ? new Date(value)\r\n            : setValueAs\r\n                ? setValueAs(value)\r\n                : value;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: null,\r\n};\r\nvar getRadioValue = (options) => Array.isArray(options)\r\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\r\n        ? {\r\n            isValid: true,\r\n            value: option.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nfunction getFieldValue(field) {\r\n    if (field && field._f) {\r\n        const ref = field._f.ref;\r\n        if (ref.disabled) {\r\n            return;\r\n        }\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field._f.refs).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field._f.refs).value;\r\n        }\r\n        return getFieldValueAs(isUndefined(ref.value) ? field._f.ref.value : ref.value, field._f);\r\n    }\r\n}\n\nvar hasValidation = (options, mounted) => mounted &&\r\n    options &&\r\n    (options.required ||\r\n        options.min ||\r\n        options.max ||\r\n        options.maxLength ||\r\n        options.minLength ||\r\n        options.pattern ||\r\n        options.validate);\n\nvar skipValidation = ({ isOnBlur, isOnChange, isOnTouch, isTouched, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (!isSubmitted && isOnTouch) {\r\n        return !(isTouched || isBlurEvent);\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isMessage = (value) => isString(value) || React.isValidElement(value);\n\nvar isRegex = (value) => value instanceof RegExp;\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) ||\r\n        (Array.isArray(result) && result.every(isMessage)) ||\r\n        (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar validateField = async ({ _f: { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, value: inputValue, valueAsNumber, mount, }, }, validateAllFieldCriteria) => {\r\n    if (!mount) {\r\n        return {};\r\n    }\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) && !ref.value) ||\r\n        inputValue === '' ||\r\n        (Array.isArray(inputValue) && !inputValue.length);\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, appendErrorsCurry(exceedMax ? maxType : minType, message));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(inputValue))) ||\r\n            (isBoolean(inputValue) && !inputValue) ||\r\n            (isCheckBox && !getCheckboxValue(refs).isValid) ||\r\n            (isRadio && !getRadioValue(refs).isValid))) {\r\n        const { value, message } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (value) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message, ref: isRadioOrCheckbox ? (refs || [])[0] || {} : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if ((!isNullOrUndefined(min) || !isNullOrUndefined(max)) &&\r\n        inputValue !== '') {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const maxOutput = getValueAndMessage(max);\r\n        const minOutput = getValueAndMessage(min);\r\n        if (!isNaN(inputValue)) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(inputValue);\r\n            if (!isNullOrUndefined(maxOutput.value)) {\r\n                exceedMax = valueNumber > maxOutput.value;\r\n            }\r\n            if (!isNullOrUndefined(minOutput.value)) {\r\n                exceedMin = valueNumber < minOutput.value;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(inputValue);\r\n            if (isString(maxOutput.value)) {\r\n                exceedMax = valueDate > new Date(maxOutput.value);\r\n            }\r\n            if (isString(minOutput.value)) {\r\n                exceedMin = valueDate < new Date(minOutput.value);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && !isEmpty && (maxLength || minLength)) {\r\n        const maxLengthOutput = getValueAndMessage(maxLength);\r\n        const minLengthOutput = getValueAndMessage(minLength);\r\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\r\n            inputValue.length > maxLengthOutput.value;\r\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\r\n            inputValue.length < minLengthOutput.value;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(inputValue) && pattern && !isEmpty) {\r\n        const { value: patternValue, message } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message,\r\n                ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const validateRef = isRadioOrCheckbox && refs ? refs[0] : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(inputValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(inputValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nvar getValidationModes = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\r\n});\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nclass Subscription {\r\n    constructor() {\r\n        this.tearDowns = [];\r\n    }\r\n    add(tearDown) {\r\n        this.tearDowns.push(tearDown);\r\n    }\r\n    unsubscribe() {\r\n        for (const teardown of this.tearDowns) {\r\n            teardown();\r\n        }\r\n        this.tearDowns = [];\r\n    }\r\n}\r\nclass Subscriber {\r\n    constructor(observer, subscription) {\r\n        this.observer = observer;\r\n        this.closed = false;\r\n        subscription.add(() => (this.closed = true));\r\n    }\r\n    next(value) {\r\n        if (!this.closed) {\r\n            this.observer.next(value);\r\n        }\r\n    }\r\n}\r\nclass Subject {\r\n    constructor() {\r\n        this.observers = [];\r\n    }\r\n    next(value) {\r\n        for (const observer of this.observers) {\r\n            observer.next(value);\r\n        }\r\n    }\r\n    subscribe(observer) {\r\n        const subscription = new Subscription();\r\n        const subscriber = new Subscriber(observer, subscription);\r\n        this.observers.push(subscriber);\r\n        return subscription;\r\n    }\r\n    unsubscribe() {\r\n        this.observers = [];\r\n    }\r\n}\n\nconst isWindowUndefined = typeof window === 'undefined';\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister, criteriaMode, } = {}) {\r\n    const fieldsRef = React.useRef({});\r\n    const fieldsNamesRef = React.useRef(new Set());\r\n    const formStateSubjectRef = React.useRef(new Subject());\r\n    const unregisterFieldsNamesRef = React.useRef(new Set());\r\n    const watchSubjectRef = React.useRef(new Subject());\r\n    const controllerSubjectRef = React.useRef(new Subject());\r\n    const fieldArraySubjectRef = React.useRef(new Subject());\r\n    const fieldArrayDefaultValuesRef = React.useRef({});\r\n    const inFieldArrayActionRef = React.useRef(false);\r\n    const watchFieldsRef = React.useRef(new Set());\r\n    const isMountedRef = React.useRef(false);\r\n    const fieldsWithValidationRef = React.useRef({});\r\n    const validFieldsRef = React.useRef({});\r\n    const defaultValuesRef = React.useRef(defaultValues);\r\n    const isWatchAllRef = React.useRef(false);\r\n    const contextRef = React.useRef(context);\r\n    const resolverRef = React.useRef(resolver);\r\n    const fieldArrayNamesRef = React.useRef(new Set());\r\n    const validationMode = getValidationModes(mode);\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const [formState, updateFormState] = React.useState({\r\n        isDirty: false,\r\n        isValidating: false,\r\n        dirtyFields: {},\r\n        isSubmitted: false,\r\n        submitCount: 0,\r\n        touchedFields: {},\r\n        isSubmitting: false,\r\n        isSubmitSuccessful: false,\r\n        isValid: !validationMode.isOnSubmit,\r\n        errors: {},\r\n    });\r\n    const readFormStateRef = React.useRef({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        touchedFields: !isProxyEnabled,\r\n        isValidating: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n        errors: !isProxyEnabled,\r\n    });\r\n    const formStateRef = React.useRef(formState);\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    const getIsValid = () => {\r\n        formStateRef.current.isValid =\r\n            deepEqual(validFieldsRef.current, fieldsWithValidationRef.current) &&\r\n                isEmptyObject(formStateRef.current.errors);\r\n        return formStateRef.current.isValid;\r\n    };\r\n    const shouldRenderBaseOnError = React.useCallback((name, error, shouldRender = false, state = {}, isValid, isWatched) => {\r\n        const previousError = get(formStateRef.current.errors, name);\r\n        if (error) {\r\n            unset(validFieldsRef.current, name);\r\n            set(formStateRef.current.errors, name, error);\r\n        }\r\n        else {\r\n            (get(fieldsWithValidationRef.current, name) || resolverRef.current) &&\r\n                set(validFieldsRef.current, name, true);\r\n            unset(formStateRef.current.errors, name);\r\n        }\r\n        if ((shouldRender ||\r\n            isWatched ||\r\n            (error ? !deepEqual(previousError, error, true) : previousError) ||\r\n            !isEmptyObject(state) ||\r\n            (readFormStateRef.current.isValid &&\r\n                formStateRef.current.isValid !==\r\n                    (resolverRef.current ? !!isValid : getIsValid()))) &&\r\n            !isNullOrUndefined(shouldRender)) {\r\n            const updatedFormState = Object.assign(Object.assign({}, state), { isValid: resolverRef.current ? !!isValid : getIsValid(), errors: formStateRef.current.errors, name });\r\n            formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), updatedFormState);\r\n            formStateSubjectRef.current.next(isWatched ? { name } : updatedFormState);\r\n        }\r\n        formStateSubjectRef.current.next({\r\n            isValidating: false,\r\n        });\r\n    }, []);\r\n    const setFieldValue = React.useCallback((name, rawValue, options = {}, shouldRender, shouldRegister) => {\r\n        shouldRegister && register(name);\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            const _f = field._f;\r\n            if (_f) {\r\n                const value = isWeb && isHTMLElement(_f.ref) && isNullOrUndefined(rawValue)\r\n                    ? ''\r\n                    : rawValue;\r\n                _f.value = getFieldValueAs(rawValue, _f);\r\n                if (isRadioInput(_f.ref)) {\r\n                    (_f.refs || []).forEach((radioRef) => (radioRef.checked = radioRef.value === value));\r\n                }\r\n                else if (isFileInput(_f.ref) && !isString(value)) {\r\n                    _f.ref.files = value;\r\n                }\r\n                else if (isMultipleSelect(_f.ref)) {\r\n                    [..._f.ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n                }\r\n                else if (isCheckBoxInput(_f.ref) && _f.refs) {\r\n                    _f.refs.length > 1\r\n                        ? _f.refs.forEach((checkboxRef) => (checkboxRef.checked = Array.isArray(value)\r\n                            ? !!value.find((data) => data === checkboxRef.value)\r\n                            : value === checkboxRef.value))\r\n                        : (_f.refs[0].checked = !!value);\r\n                }\r\n                else {\r\n                    _f.ref.value = value;\r\n                }\r\n                if (shouldRender) {\r\n                    const values = getFieldsValues(fieldsRef);\r\n                    set(values, name, rawValue);\r\n                    controllerSubjectRef.current.next({\r\n                        values: Object.assign(Object.assign({}, defaultValuesRef.current), values),\r\n                        name,\r\n                    });\r\n                }\r\n                options.shouldDirty && updateAndGetDirtyState(name, value);\r\n                options.shouldValidate && trigger(name);\r\n            }\r\n            else {\r\n                field._f = {\r\n                    ref: {\r\n                        name,\r\n                        value: rawValue,\r\n                    },\r\n                    value: rawValue,\r\n                };\r\n            }\r\n        }\r\n    }, []);\r\n    const getIsDirty = React.useCallback((name, data) => {\r\n        const formValues = getFieldsValues(fieldsRef);\r\n        name && data && set(formValues, name, data);\r\n        return !deepEqual(formValues, defaultValuesRef.current);\r\n    }, []);\r\n    const updateAndGetDirtyState = React.useCallback((name, inputValue, shouldRender = true) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            const isFieldDirty = !deepEqual(get(defaultValuesRef.current, name), inputValue);\r\n            const isDirtyFieldExist = get(formStateRef.current.dirtyFields, name);\r\n            const previousIsDirty = formStateRef.current.isDirty;\r\n            isFieldDirty\r\n                ? set(formStateRef.current.dirtyFields, name, true)\r\n                : unset(formStateRef.current.dirtyFields, name);\r\n            formStateRef.current.isDirty = getIsDirty();\r\n            const state = {\r\n                isDirty: formStateRef.current.isDirty,\r\n                dirtyFields: formStateRef.current.dirtyFields,\r\n                name,\r\n            };\r\n            const isChanged = (readFormStateRef.current.isDirty &&\r\n                previousIsDirty !== state.isDirty) ||\r\n                (readFormStateRef.current.dirtyFields &&\r\n                    isDirtyFieldExist !== get(formStateRef.current.dirtyFields, name));\r\n            isChanged && shouldRender && formStateSubjectRef.current.next(state);\r\n            return isChanged ? state : {};\r\n        }\r\n        return {};\r\n    }, []);\r\n    const executeValidation = React.useCallback(async (name, skipReRender) => {\r\n        const error = (await validateField(get(fieldsRef.current, name), isValidateAllFieldCriteria))[name];\r\n        shouldRenderBaseOnError(name, error, skipReRender);\r\n        return isUndefined(error);\r\n    }, [isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = React.useCallback(async (names, currentNames = []) => {\r\n        const { errors } = await resolverRef.current(getFieldsValues(fieldsRef), contextRef.current, {\r\n            criteriaMode,\r\n            names: currentNames,\r\n            fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n        });\r\n        for (const name of names) {\r\n            const error = get(errors, name);\r\n            error\r\n                ? set(formStateRef.current.errors, name, error)\r\n                : unset(formStateRef.current.errors, name);\r\n        }\r\n        return errors;\r\n    }, [criteriaMode]);\r\n    const validateForm = async (fieldsRef) => {\r\n        for (const name in fieldsRef) {\r\n            const field = fieldsRef[name];\r\n            if (field) {\r\n                const _f = field._f;\r\n                const current = omit(field, '_f');\r\n                if (_f) {\r\n                    const fieldError = await validateField(field, isValidateAllFieldCriteria);\r\n                    if (fieldError[_f.name]) {\r\n                        set(formStateRef.current.errors, _f.name, fieldError[_f.name]);\r\n                        unset(validFieldsRef.current, _f.name);\r\n                    }\r\n                    else if (get(fieldsWithValidationRef.current, _f.name)) {\r\n                        set(validFieldsRef.current, _f.name, true);\r\n                        unset(formStateRef.current.errors, _f.name);\r\n                    }\r\n                }\r\n                current && (await validateForm(current));\r\n            }\r\n        }\r\n    };\r\n    const trigger = React.useCallback(async (name, options = {}) => {\r\n        const fieldNames = isUndefined(name)\r\n            ? Object.keys(fieldsRef.current)\r\n            : convertToArrayPayload(name);\r\n        let isValid;\r\n        let schemaResult = {};\r\n        formStateSubjectRef.current.next({\r\n            isValidating: true,\r\n        });\r\n        if (resolverRef.current) {\r\n            schemaResult = await executeSchemaOrResolverValidation(fieldNames, isUndefined(name)\r\n                ? undefined\r\n                : fieldNames);\r\n            isValid = fieldNames.every((name) => !get(schemaResult, name));\r\n        }\r\n        else {\r\n            if (isUndefined(name)) {\r\n                await validateForm(fieldsRef.current);\r\n                isValid = isEmptyObject(formStateRef.current.errors);\r\n            }\r\n            else {\r\n                isValid = (await Promise.all(fieldNames\r\n                    .filter((fieldName) => get(fieldsRef.current, fieldName))\r\n                    .map(async (fieldName) => await executeValidation(fieldName, null)))).every(Boolean);\r\n            }\r\n        }\r\n        formStateSubjectRef.current.next(Object.assign(Object.assign({}, (isString(name) ? { name } : {})), { errors: formStateRef.current.errors, isValidating: false, isValid: resolverRef.current\r\n                ? isEmptyObject(schemaResult)\r\n                : getIsValid() }));\r\n        if (!isValid && options.shouldFocus) {\r\n            focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), fieldNames);\r\n        }\r\n        return isValid;\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = React.useCallback((name, value, options) => Object.entries(value).forEach(([inputKey, inputValue]) => {\r\n        const fieldName = `${name}.${inputKey}`;\r\n        const field = get(fieldsRef.current, fieldName);\r\n        const isFieldArray = fieldArrayNamesRef.current.has(name);\r\n        isFieldArray || !isPrimitive(inputValue) || (field && !field._f)\r\n            ? setInternalValues(fieldName, inputValue, options)\r\n            : setFieldValue(fieldName, inputValue, options, true, !field);\r\n    }), [trigger]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const updateValidAndValue = (name, options, ref, isWithinRefCallback) => {\r\n        const field = get(fieldsRef.current, name);\r\n        const defaultValue = isUndefined(field._f.value)\r\n            ? get(defaultValuesRef.current, name)\r\n            : field._f.value;\r\n        if (field && !isUndefined(defaultValue)) {\r\n            if (ref && ref.defaultChecked) {\r\n                field._f.value = getFieldValue(field);\r\n            }\r\n            else if (!isNameInFieldArray(fieldArrayNamesRef.current, name)) {\r\n                setFieldValue(name, defaultValue);\r\n            }\r\n            else {\r\n                field._f.value = defaultValue;\r\n            }\r\n        }\r\n        else {\r\n            field._f.value = getFieldValue(field);\r\n        }\r\n        if ((!isUndefined(defaultValue) || isWithinRefCallback) &&\r\n            hasValidation(options, field._f.mount) &&\r\n            !validationMode.isOnSubmit &&\r\n            field &&\r\n            readFormStateRef.current.isValid) {\r\n            validateField(field, isValidateAllFieldCriteria).then((error) => {\r\n                isEmptyObject(error)\r\n                    ? set(validFieldsRef.current, name, true)\r\n                    : unset(validFieldsRef.current, name);\r\n                formStateRef.current.isValid !== getIsValid() &&\r\n                    updateFormState(Object.assign(Object.assign({}, formStateRef.current), { isValid: getIsValid() }));\r\n            });\r\n        }\r\n        return defaultValue;\r\n    };\r\n    const setValue = (name, value, options = {}) => {\r\n        const field = get(fieldsRef.current, name);\r\n        const isFieldArray = fieldArrayNamesRef.current.has(name);\r\n        if (isFieldArray) {\r\n            fieldArraySubjectRef.current.next({\r\n                fields: value,\r\n                name,\r\n                isReset: true,\r\n            });\r\n            if ((readFormStateRef.current.isDirty ||\r\n                readFormStateRef.current.dirtyFields) &&\r\n                options.shouldDirty) {\r\n                set(formStateRef.current.dirtyFields, name, setFieldArrayDirtyFields(value, get(defaultValuesRef.current, name, []), get(formStateRef.current.dirtyFields, name, [])));\r\n                formStateSubjectRef.current.next({\r\n                    name,\r\n                    dirtyFields: formStateRef.current.dirtyFields,\r\n                    isDirty: getIsDirty(name, value),\r\n                });\r\n            }\r\n            !value.length &&\r\n                set(fieldsRef.current, name, []) &&\r\n                set(fieldArrayDefaultValuesRef.current, name, []);\r\n        }\r\n        ((field && !field._f) || isFieldArray) && !isNullOrUndefined(value)\r\n            ? setInternalValues(name, value, isFieldArray ? {} : options)\r\n            : setFieldValue(name, value, options, true, !field);\r\n        isFieldWatched(name) && formStateSubjectRef.current.next({});\r\n        watchSubjectRef.current.next({ name, formValues: getValues() });\r\n    };\r\n    const handleChange = React.useCallback(async ({ type, target, target: { value, type: inputType } }) => {\r\n        let name = target.name;\r\n        let error;\r\n        let isValid;\r\n        const field = get(fieldsRef.current, name);\r\n        if (field) {\r\n            let inputValue = inputType ? getFieldValue(field) : undefined;\r\n            inputValue = isUndefined(inputValue) ? value : inputValue;\r\n            const isBlurEvent = type === EVENTS.BLUR;\r\n            const { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange, } = getValidationModes(reValidateMode);\r\n            const shouldSkipValidation = (!hasValidation(field._f, field._f.mount) &&\r\n                !resolverRef.current &&\r\n                !get(formStateRef.current.errors, name)) ||\r\n                skipValidation(Object.assign({ isBlurEvent, isTouched: !!get(formStateRef.current.touchedFields, name), isSubmitted: formStateRef.current.isSubmitted, isReValidateOnBlur,\r\n                    isReValidateOnChange }, validationMode));\r\n            const isWatched = !isBlurEvent && isFieldWatched(name);\r\n            if (!isUndefined(inputValue)) {\r\n                field._f.value = inputValue;\r\n            }\r\n            const state = updateAndGetDirtyState(name, field._f.value, false);\r\n            if (isBlurEvent && !get(formStateRef.current.touchedFields, name)) {\r\n                set(formStateRef.current.touchedFields, name, true);\r\n                readFormStateRef.current.touchedFields &&\r\n                    (state.touchedFields = formStateRef.current.touchedFields);\r\n            }\r\n            let shouldRender = !isEmptyObject(state) || isWatched;\r\n            if (shouldSkipValidation) {\r\n                !isBlurEvent &&\r\n                    watchSubjectRef.current.next({\r\n                        name,\r\n                        type,\r\n                        formValues: getValues(),\r\n                    });\r\n                return (shouldRender &&\r\n                    formStateSubjectRef.current.next(isWatched ? { name } : Object.assign(Object.assign({}, state), { name })));\r\n            }\r\n            formStateSubjectRef.current.next({\r\n                isValidating: true,\r\n            });\r\n            if (resolverRef.current) {\r\n                const { errors } = await resolverRef.current(getFieldsValues(fieldsRef), contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields([name], fieldsRef.current),\r\n                    names: [name],\r\n                });\r\n                const previousFormIsValid = formStateRef.current.isValid;\r\n                error = get(errors, name);\r\n                if (isCheckBoxInput(target) && !error) {\r\n                    const parentNodeName = getNodeParentName(name);\r\n                    const currentError = get(errors, parentNodeName, {});\r\n                    currentError.type && currentError.message && (error = currentError);\r\n                    if (currentError ||\r\n                        get(formStateRef.current.errors, parentNodeName)) {\r\n                        name = parentNodeName;\r\n                    }\r\n                }\r\n                isValid = isEmptyObject(errors);\r\n                previousFormIsValid !== isValid && (shouldRender = true);\r\n            }\r\n            else {\r\n                error = (await validateField(field, isValidateAllFieldCriteria))[name];\r\n            }\r\n            !isBlurEvent &&\r\n                watchSubjectRef.current.next({\r\n                    name,\r\n                    type,\r\n                    formValues: getValues(),\r\n                });\r\n            shouldRenderBaseOnError(name, error, shouldRender, state, isValid, isWatched);\r\n        }\r\n    }, []);\r\n    const getValues = (fieldNames) => {\r\n        const values = Object.assign(Object.assign({}, defaultValuesRef.current), getFieldsValues(fieldsRef));\r\n        return isUndefined(fieldNames)\r\n            ? values\r\n            : isString(fieldNames)\r\n                ? get(values, fieldNames)\r\n                : fieldNames.map((name) => get(values, name));\r\n    };\r\n    const updateIsValid = React.useCallback(async (values = {}) => {\r\n        const previousIsValid = formStateRef.current.isValid;\r\n        if (resolver) {\r\n            const { errors } = await resolverRef.current(Object.assign(Object.assign({}, getFieldsValues(fieldsRef)), values), contextRef.current, {\r\n                criteriaMode,\r\n                fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n            });\r\n            formStateRef.current.isValid = isEmptyObject(errors);\r\n        }\r\n        else {\r\n            getIsValid();\r\n        }\r\n        previousIsValid !== formStateRef.current.isValid &&\r\n            formStateSubjectRef.current.next({\r\n                isValid: formStateRef.current.isValid,\r\n            });\r\n    }, [criteriaMode]);\r\n    const clearErrors = (name) => {\r\n        name\r\n            ? convertToArrayPayload(name).forEach((inputName) => unset(formStateRef.current.errors, inputName))\r\n            : (formStateRef.current.errors = {});\r\n        formStateSubjectRef.current.next({\r\n            errors: formStateRef.current.errors,\r\n        });\r\n    };\r\n    const setError = (name, error, options) => {\r\n        const ref = ((get(fieldsRef.current, name) || { _f: {} })._f || {}).ref;\r\n        set(formStateRef.current.errors, name, Object.assign(Object.assign({}, error), { ref }));\r\n        formStateSubjectRef.current.next({\r\n            name,\r\n            errors: formStateRef.current.errors,\r\n            isValid: false,\r\n        });\r\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\r\n    };\r\n    const watchInternal = React.useCallback((fieldNames, defaultValue, isGlobal, formValues) => {\r\n        const isArrayNames = Array.isArray(fieldNames);\r\n        const fieldValues = formValues || isMountedRef.current\r\n            ? Object.assign(Object.assign({}, defaultValuesRef.current), (formValues || getFieldsValues(fieldsRef))) : isUndefined(defaultValue)\r\n            ? defaultValuesRef.current\r\n            : isArrayNames\r\n                ? defaultValue\r\n                : { [fieldNames]: defaultValue };\r\n        if (isUndefined(fieldNames)) {\r\n            isGlobal && (isWatchAllRef.current = true);\r\n            return fieldValues;\r\n        }\r\n        const result = [];\r\n        for (const fieldName of convertToArrayPayload(fieldNames)) {\r\n            isGlobal && watchFieldsRef.current.add(fieldName);\r\n            result.push(get(fieldValues, fieldName));\r\n        }\r\n        return isArrayNames ? result : result[0];\r\n    }, []);\r\n    const watch = (fieldName, defaultValue) => isFunction(fieldName)\r\n        ? watchSubjectRef.current.subscribe({\r\n            next: (info) => fieldName(watchInternal(undefined, defaultValue), info),\r\n        })\r\n        : watchInternal(fieldName, defaultValue, true);\r\n    const unregister = (name, options = {}) => {\r\n        for (const inputName of name\r\n            ? convertToArrayPayload(name)\r\n            : Object.keys(fieldsNamesRef.current)) {\r\n            fieldsNamesRef.current.delete(inputName);\r\n            fieldArrayNamesRef.current.delete(inputName);\r\n            if (get(fieldsRef.current, inputName)) {\r\n                if (!options.keepIsValid) {\r\n                    unset(fieldsWithValidationRef.current, inputName);\r\n                    unset(validFieldsRef.current, inputName);\r\n                }\r\n                !options.keepError && unset(formStateRef.current.errors, inputName);\r\n                !options.keepValue && unset(fieldsRef.current, inputName);\r\n                !options.keepDirty &&\r\n                    unset(formStateRef.current.dirtyFields, inputName);\r\n                !options.keepTouched &&\r\n                    unset(formStateRef.current.touchedFields, inputName);\r\n                !shouldUnregister &&\r\n                    !options.keepDefaultValue &&\r\n                    unset(defaultValuesRef.current, inputName);\r\n                watchSubjectRef.current.next({\r\n                    name: inputName,\r\n                    formValues: getValues(),\r\n                });\r\n            }\r\n        }\r\n        formStateSubjectRef.current.next(Object.assign(Object.assign(Object.assign({}, formStateRef.current), (!options.keepDirty ? {} : { isDirty: getIsDirty() })), (resolverRef.current ? {} : { isValid: getIsValid() })));\r\n        !options.keepIsValid && updateIsValid();\r\n    };\r\n    const registerFieldRef = (name, ref, options) => {\r\n        register(name, options);\r\n        let field = get(fieldsRef.current, name);\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        if (ref === field._f.ref ||\r\n            (isWeb && isHTMLElement(field._f.ref) && !isHTMLElement(ref)) ||\r\n            (isRadioOrCheckbox &&\r\n                Array.isArray(field._f.refs) &&\r\n                compact(field._f.refs).find((option) => option === ref))) {\r\n            return;\r\n        }\r\n        field = {\r\n            _f: isRadioOrCheckbox\r\n                ? Object.assign(Object.assign({}, field._f), { refs: [\r\n                        ...compact(field._f.refs || []).filter((ref) => isHTMLElement(ref) && document.contains(ref)),\r\n                        ref,\r\n                    ], ref: { type: ref.type, name } }) : Object.assign(Object.assign({}, field._f), { ref }),\r\n        };\r\n        set(fieldsRef.current, name, field);\r\n        const defaultValue = updateValidAndValue(name, options, ref, true);\r\n        if (isRadioOrCheckbox && Array.isArray(defaultValue)\r\n            ? !deepEqual(get(fieldsRef.current, name)._f.value, defaultValue)\r\n            : isUndefined(get(fieldsRef.current, name)._f.value)) {\r\n            get(fieldsRef.current, name)._f.value = getFieldValue(get(fieldsRef.current, name));\r\n        }\r\n    };\r\n    const register = React.useCallback((name, options = {}) => {\r\n        const field = get(fieldsRef.current, name);\r\n        set(fieldsRef.current, name, {\r\n            _f: Object.assign(Object.assign(Object.assign({}, (field && field._f ? field._f : { ref: { name } })), { name, mount: true }), options),\r\n        });\r\n        hasValidation(options, true) &&\r\n            set(fieldsWithValidationRef.current, name, true);\r\n        fieldsNamesRef.current.add(name);\r\n        !field && updateValidAndValue(name, options);\r\n        return isWindowUndefined\r\n            ? { name: name }\r\n            : {\r\n                name,\r\n                onChange: handleChange,\r\n                onBlur: handleChange,\r\n                ref: (ref) => {\r\n                    if (ref) {\r\n                        registerFieldRef(name, ref, options);\r\n                    }\r\n                    else {\r\n                        const field = get(fieldsRef.current, name, {});\r\n                        const shouldUnmount = shouldUnregister || options.shouldUnregister;\r\n                        if (field._f) {\r\n                            field._f.mount = false;\r\n                            // If initial state of field element is disabled,\r\n                            // value is not set on first \"register\"\r\n                            // re-sync the value in when it switched to enabled\r\n                            if (isUndefined(field._f.value)) {\r\n                                field._f.value = field._f.ref.value;\r\n                            }\r\n                        }\r\n                        if (isNameInFieldArray(fieldArrayNamesRef.current, name)\r\n                            ? shouldUnmount && !inFieldArrayActionRef.current\r\n                            : shouldUnmount) {\r\n                            unregisterFieldsNamesRef.current.add(name);\r\n                        }\r\n                    }\r\n                },\r\n            };\r\n    }, []);\r\n    const handleSubmit = React.useCallback((onValid, onInvalid) => async (e) => {\r\n        if (e) {\r\n            e.preventDefault && e.preventDefault();\r\n            e.persist && e.persist();\r\n        }\r\n        let hasNoPromiseError = true;\r\n        let fieldValues = getFieldsValues(fieldsRef);\r\n        formStateSubjectRef.current.next({\r\n            isSubmitting: true,\r\n        });\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, {\r\n                    criteriaMode,\r\n                    fields: getFields(fieldsNamesRef.current, fieldsRef.current),\r\n                });\r\n                formStateRef.current.errors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                await validateForm(fieldsRef.current);\r\n            }\r\n            if (isEmptyObject(formStateRef.current.errors) &&\r\n                Object.keys(formStateRef.current.errors).every((name) => get(fieldValues, name))) {\r\n                formStateSubjectRef.current.next({\r\n                    errors: {},\r\n                    isSubmitting: true,\r\n                });\r\n                await onValid(fieldValues, e);\r\n            }\r\n            else {\r\n                onInvalid && (await onInvalid(formStateRef.current.errors, e));\r\n                shouldFocusError &&\r\n                    focusFieldBy(fieldsRef.current, (key) => get(formStateRef.current.errors, key), fieldsNamesRef.current);\r\n            }\r\n        }\r\n        catch (err) {\r\n            hasNoPromiseError = false;\r\n            throw err;\r\n        }\r\n        finally {\r\n            formStateRef.current.isSubmitted = true;\r\n            formStateSubjectRef.current.next({\r\n                isSubmitted: true,\r\n                isSubmitting: false,\r\n                isSubmitSuccessful: isEmptyObject(formStateRef.current.errors) && hasNoPromiseError,\r\n                submitCount: formStateRef.current.submitCount + 1,\r\n                errors: formStateRef.current.errors,\r\n            });\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria, criteriaMode]);\r\n    const resetFromState = React.useCallback(({ keepErrors, keepDirty, keepIsSubmitted, keepTouched, keepDefaultValues, keepIsValid, keepSubmitCount, }, values) => {\r\n        if (!keepIsValid) {\r\n            validFieldsRef.current = {};\r\n            fieldsWithValidationRef.current = {};\r\n        }\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n        formStateSubjectRef.current.next({\r\n            submitCount: keepSubmitCount ? formStateRef.current.submitCount : 0,\r\n            isDirty: keepDirty\r\n                ? formStateRef.current.isDirty\r\n                : keepDefaultValues\r\n                    ? deepEqual(values, defaultValuesRef.current)\r\n                    : false,\r\n            isSubmitted: keepIsSubmitted ? formStateRef.current.isSubmitted : false,\r\n            isValid: keepIsValid\r\n                ? formStateRef.current.isValid\r\n                : !!updateIsValid(values),\r\n            dirtyFields: keepDirty ? formStateRef.current.dirtyFields : {},\r\n            touchedFields: keepTouched ? formStateRef.current.touchedFields : {},\r\n            errors: keepErrors ? formStateRef.current.errors : {},\r\n            isSubmitting: false,\r\n            isSubmitSuccessful: false,\r\n        });\r\n    }, []);\r\n    const registerAbsentFields = (value, name = '') => {\r\n        const field = get(fieldsRef.current, name);\r\n        if (!field || (field && !field._f)) {\r\n            if (!field &&\r\n                (isPrimitive(value) ||\r\n                    (isWeb && (value instanceof FileList || value instanceof Date)))) {\r\n                set(fieldsRef.current, name, {\r\n                    _f: {\r\n                        ref: { name, value },\r\n                        value,\r\n                        name,\r\n                    },\r\n                });\r\n            }\r\n            if (Array.isArray(value) || isObject(value)) {\r\n                if (name && !get(fieldsRef.current, name)) {\r\n                    set(fieldsRef.current, name, Array.isArray(value) ? [] : {});\r\n                }\r\n                for (const key in value) {\r\n                    registerAbsentFields(value[key], name + (name ? '.' : '') + key);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    const reset = (values, keepStateOptions = {}) => {\r\n        const updatedValues = values || defaultValuesRef.current;\r\n        if (isWeb && !keepStateOptions.keepValues) {\r\n            for (const name of fieldsNamesRef.current) {\r\n                const field = get(fieldsRef.current, name);\r\n                if (field && field._f) {\r\n                    const inputRef = Array.isArray(field._f.refs)\r\n                        ? field._f.refs[0]\r\n                        : field._f.ref;\r\n                    try {\r\n                        isHTMLElement(inputRef) && inputRef.closest('form').reset();\r\n                        break;\r\n                    }\r\n                    catch (_a) { }\r\n                }\r\n            }\r\n        }\r\n        !keepStateOptions.keepDefaultValues &&\r\n            (defaultValuesRef.current = Object.assign({}, updatedValues));\r\n        if (!keepStateOptions.keepValues) {\r\n            fieldsRef.current = {};\r\n            controllerSubjectRef.current.next({\r\n                values: Object.assign({}, updatedValues),\r\n            });\r\n            watchSubjectRef.current.next({\r\n                formValues: Object.assign({}, updatedValues),\r\n            });\r\n            fieldArraySubjectRef.current.next({\r\n                fields: Object.assign({}, updatedValues),\r\n                isReset: true,\r\n            });\r\n        }\r\n        !keepStateOptions.keepDefaultValues &&\r\n            !shouldUnregister &&\r\n            registerAbsentFields(Object.assign({}, updatedValues));\r\n        resetFromState(keepStateOptions, values);\r\n    };\r\n    const setFocus = (name) => get(fieldsRef.current, name)._f.ref.focus();\r\n    React.useEffect(() => {\r\n        !shouldUnregister && registerAbsentFields(defaultValuesRef.current);\r\n        const formStateSubscription = formStateSubjectRef.current.subscribe({\r\n            next(formState) {\r\n                if (shouldRenderFormState(formState, readFormStateRef.current, true)) {\r\n                    formStateRef.current = Object.assign(Object.assign({}, formStateRef.current), formState);\r\n                    updateFormState(formStateRef.current);\r\n                }\r\n            },\r\n        });\r\n        const useFieldArraySubscription = fieldArraySubjectRef.current.subscribe({\r\n            next(state) {\r\n                if (state.fields && state.name && readFormStateRef.current.isValid) {\r\n                    const values = getFieldsValues(fieldsRef);\r\n                    set(values, state.name, state.fields);\r\n                    updateIsValid(values);\r\n                }\r\n            },\r\n        });\r\n        resolverRef.current && readFormStateRef.current.isValid && updateIsValid();\r\n        return () => {\r\n            watchSubjectRef.current.unsubscribe();\r\n            formStateSubscription.unsubscribe();\r\n            useFieldArraySubscription.unsubscribe();\r\n        };\r\n    }, []);\r\n    React.useEffect(() => {\r\n        const isLiveInDom = (ref) => !isHTMLElement(ref) || !document.contains(ref);\r\n        isMountedRef.current = true;\r\n        for (const name of unregisterFieldsNamesRef.current) {\r\n            const field = get(fieldsRef.current, name);\r\n            field &&\r\n                (field._f.refs\r\n                    ? field._f.refs.every(isLiveInDom)\r\n                    : isLiveInDom(field._f.ref)) &&\r\n                unregister(name);\r\n        }\r\n        unregisterFieldsNamesRef.current = new Set();\r\n    });\r\n    return {\r\n        control: React.useMemo(() => ({\r\n            register,\r\n            isWatchAllRef,\r\n            inFieldArrayActionRef,\r\n            watchFieldsRef,\r\n            getIsDirty,\r\n            formStateSubjectRef,\r\n            fieldArraySubjectRef,\r\n            controllerSubjectRef,\r\n            watchSubjectRef,\r\n            watchInternal,\r\n            fieldsRef,\r\n            validFieldsRef,\r\n            fieldsWithValidationRef,\r\n            fieldArrayNamesRef,\r\n            readFormStateRef,\r\n            formStateRef,\r\n            defaultValuesRef,\r\n            fieldArrayDefaultValuesRef,\r\n            unregister,\r\n            shouldUnmount: shouldUnregister,\r\n        }), []),\r\n        formState: getProxyFormState(isProxyEnabled, formState, readFormStateRef),\r\n        trigger,\r\n        register,\r\n        handleSubmit,\r\n        watch: React.useCallback(watch, []),\r\n        setValue: React.useCallback(setValue, [setInternalValues]),\r\n        getValues: React.useCallback(getValues, []),\r\n        reset: React.useCallback(reset, []),\r\n        clearErrors: React.useCallback(clearErrors, []),\r\n        unregister: React.useCallback(unregister, []),\r\n        setError: React.useCallback(setError, []),\r\n        setFocus: React.useCallback(setFocus, []),\r\n    };\r\n}\n\nfunction useWatch(props) {\r\n    const { control, name, defaultValue } = props || {};\r\n    const methods = useFormContext();\r\n    const nameRef = React.useRef(name);\r\n    nameRef.current = name;\r\n    const { watchInternal, watchSubjectRef } = control || methods.control;\r\n    const [value, updateValue] = React.useState(isUndefined(defaultValue)\r\n        ? watchInternal(name)\r\n        : defaultValue);\r\n    React.useEffect(() => {\r\n        watchInternal(name);\r\n        const watchSubscription = watchSubjectRef.current.subscribe({\r\n            next: ({ name: inputName, formValues }) => (!nameRef.current ||\r\n                !inputName ||\r\n                convertToArrayPayload(nameRef.current).some((fieldName) => inputName &&\r\n                    fieldName &&\r\n                    (fieldName.startsWith(inputName) ||\r\n                        inputName.startsWith(fieldName)))) &&\r\n                updateValue(watchInternal(nameRef.current, defaultValue, false, formValues)),\r\n        });\r\n        return () => watchSubscription.unsubscribe();\r\n    }, []);\r\n    return value;\r\n}\n\nexport { Controller, FormProvider, appendErrors, get, set, useController, useFieldArray, useForm, useFormContext, useFormState, useWatch };\n//# sourceMappingURL=index.esm.js.map\n"],"sourceRoot":""}